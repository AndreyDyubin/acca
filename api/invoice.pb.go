// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/invoice.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NewInvoiceRequest struct {
	// key внешний уникальный идентицитора инвойса.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// strategy стратегия работы с инвойсом.
	Strategy             string   `protobuf:"bytes,2,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Meta                 *[]byte  `protobuf:"bytes,3,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewInvoiceRequest) Reset()         { *m = NewInvoiceRequest{} }
func (m *NewInvoiceRequest) String() string { return proto.CompactTextString(m) }
func (*NewInvoiceRequest) ProtoMessage()    {}
func (*NewInvoiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{0}
}
func (m *NewInvoiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewInvoiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewInvoiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewInvoiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewInvoiceRequest.Merge(m, src)
}
func (m *NewInvoiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewInvoiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewInvoiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewInvoiceRequest proto.InternalMessageInfo

func (m *NewInvoiceRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *NewInvoiceRequest) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *NewInvoiceRequest) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

type NewInvoiceResponse struct {
	InvoiceId            int64    `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewInvoiceResponse) Reset()         { *m = NewInvoiceResponse{} }
func (m *NewInvoiceResponse) String() string { return proto.CompactTextString(m) }
func (*NewInvoiceResponse) ProtoMessage()    {}
func (*NewInvoiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{1}
}
func (m *NewInvoiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewInvoiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewInvoiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewInvoiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewInvoiceResponse.Merge(m, src)
}
func (m *NewInvoiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *NewInvoiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewInvoiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewInvoiceResponse proto.InternalMessageInfo

func (m *NewInvoiceResponse) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

type GetInvoiceByIDsRequest struct {
	InvoiceIds           []int64  `protobuf:"varint,1,rep,packed,name=invoice_ids,json=invoiceIds,proto3" json:"invoice_ids,omitempty"`
	WithTx               bool     `protobuf:"varint,2,opt,name=with_tx,json=withTx,proto3" json:"with_tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetInvoiceByIDsRequest) Reset()         { *m = GetInvoiceByIDsRequest{} }
func (m *GetInvoiceByIDsRequest) String() string { return proto.CompactTextString(m) }
func (*GetInvoiceByIDsRequest) ProtoMessage()    {}
func (*GetInvoiceByIDsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{2}
}
func (m *GetInvoiceByIDsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInvoiceByIDsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInvoiceByIDsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInvoiceByIDsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInvoiceByIDsRequest.Merge(m, src)
}
func (m *GetInvoiceByIDsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetInvoiceByIDsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInvoiceByIDsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInvoiceByIDsRequest proto.InternalMessageInfo

func (m *GetInvoiceByIDsRequest) GetInvoiceIds() []int64 {
	if m != nil {
		return m.InvoiceIds
	}
	return nil
}

func (m *GetInvoiceByIDsRequest) GetWithTx() bool {
	if m != nil {
		return m.WithTx
	}
	return false
}

type GetInvoiceByIDsResponse struct {
	Invoices             []*GetInvoiceByIDsResponse_Invoice `protobuf:"bytes,1,rep,name=invoices,proto3" json:"invoices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *GetInvoiceByIDsResponse) Reset()         { *m = GetInvoiceByIDsResponse{} }
func (m *GetInvoiceByIDsResponse) String() string { return proto.CompactTextString(m) }
func (*GetInvoiceByIDsResponse) ProtoMessage()    {}
func (*GetInvoiceByIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{3}
}
func (m *GetInvoiceByIDsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInvoiceByIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInvoiceByIDsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInvoiceByIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInvoiceByIDsResponse.Merge(m, src)
}
func (m *GetInvoiceByIDsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetInvoiceByIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInvoiceByIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetInvoiceByIDsResponse proto.InternalMessageInfo

func (m *GetInvoiceByIDsResponse) GetInvoices() []*GetInvoiceByIDsResponse_Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

type GetInvoiceByIDsResponse_Invoice struct {
	// invoice_id внутренний идентификатор инвойса.
	InvoiceId int64 `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// key внешний уникальный идентицитора инвойса.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// status состояние инвойса.
	Status InvoiceStatus `protobuf:"varint,3,opt,name=status,proto3,enum=api.InvoiceStatus" json:"status,omitempty"`
	// next_status куда переходит инвойс.
	NextStatus InvoiceStatus `protobuf:"varint,4,opt,name=next_status,json=nextStatus,proto3,enum=api.InvoiceStatus" json:"next_status,omitempty"`
	// strategy стратегия работы с инвойсом.
	Strategy             string     `protobuf:"bytes,5,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Meta                 *[]byte    `protobuf:"bytes,6,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	CreatedAt            *time.Time `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt            *time.Time `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	Transactions         []*Tx      `protobuf:"bytes,9,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetInvoiceByIDsResponse_Invoice) Reset()         { *m = GetInvoiceByIDsResponse_Invoice{} }
func (m *GetInvoiceByIDsResponse_Invoice) String() string { return proto.CompactTextString(m) }
func (*GetInvoiceByIDsResponse_Invoice) ProtoMessage()    {}
func (*GetInvoiceByIDsResponse_Invoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{3, 0}
}
func (m *GetInvoiceByIDsResponse_Invoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInvoiceByIDsResponse_Invoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInvoiceByIDsResponse_Invoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInvoiceByIDsResponse_Invoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInvoiceByIDsResponse_Invoice.Merge(m, src)
}
func (m *GetInvoiceByIDsResponse_Invoice) XXX_Size() int {
	return m.Size()
}
func (m *GetInvoiceByIDsResponse_Invoice) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInvoiceByIDsResponse_Invoice.DiscardUnknown(m)
}

var xxx_messageInfo_GetInvoiceByIDsResponse_Invoice proto.InternalMessageInfo

func (m *GetInvoiceByIDsResponse_Invoice) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

func (m *GetInvoiceByIDsResponse_Invoice) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GetInvoiceByIDsResponse_Invoice) GetStatus() InvoiceStatus {
	if m != nil {
		return m.Status
	}
	return InvoiceStatus_UNKNOWN_I
}

func (m *GetInvoiceByIDsResponse_Invoice) GetNextStatus() InvoiceStatus {
	if m != nil {
		return m.NextStatus
	}
	return InvoiceStatus_UNKNOWN_I
}

func (m *GetInvoiceByIDsResponse_Invoice) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *GetInvoiceByIDsResponse_Invoice) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *GetInvoiceByIDsResponse_Invoice) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *GetInvoiceByIDsResponse_Invoice) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *GetInvoiceByIDsResponse_Invoice) GetTransactions() []*Tx {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type AddTransactionToInvoiceRequest struct {
	// invoice_id связанный с транзакцией инвойс.
	InvoiceId int64 `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// key Уникальный внешний идентификатор транзакции (опционально).
	Key *string `protobuf:"bytes,2,opt,name=key,proto3,wktptr" json:"key,omitempty"`
	// strategy стратегия работы с инвойсом.
	Strategy             string                                 `protobuf:"bytes,3,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Meta                 *[]byte                                `protobuf:"bytes,4,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	Operations           []*AddTransactionToInvoiceRequest_Oper `protobuf:"bytes,5,rep,name=operations,proto3" json:"operations,omitempty"`
	Amount               int64                                  `protobuf:"varint,6,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *AddTransactionToInvoiceRequest) Reset()         { *m = AddTransactionToInvoiceRequest{} }
func (m *AddTransactionToInvoiceRequest) String() string { return proto.CompactTextString(m) }
func (*AddTransactionToInvoiceRequest) ProtoMessage()    {}
func (*AddTransactionToInvoiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{4}
}
func (m *AddTransactionToInvoiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTransactionToInvoiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTransactionToInvoiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTransactionToInvoiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTransactionToInvoiceRequest.Merge(m, src)
}
func (m *AddTransactionToInvoiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddTransactionToInvoiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTransactionToInvoiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTransactionToInvoiceRequest proto.InternalMessageInfo

func (m *AddTransactionToInvoiceRequest) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

func (m *AddTransactionToInvoiceRequest) GetKey() *string {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AddTransactionToInvoiceRequest) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *AddTransactionToInvoiceRequest) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AddTransactionToInvoiceRequest) GetOperations() []*AddTransactionToInvoiceRequest_Oper {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *AddTransactionToInvoiceRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type AddTransactionToInvoiceRequest_Oper struct {
	SrcAccId             int64        `protobuf:"varint,1,opt,name=src_acc_id,json=srcAccId,proto3" json:"src_acc_id,omitempty"`
	DstAccId             int64        `protobuf:"varint,2,opt,name=dst_acc_id,json=dstAccId,proto3" json:"dst_acc_id,omitempty"`
	Strategy             OperStrategy `protobuf:"varint,3,opt,name=strategy,proto3,enum=api.OperStrategy" json:"strategy,omitempty"`
	Amount               int64        `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
	Key                  *string      `protobuf:"bytes,5,opt,name=key,proto3,wktptr" json:"key,omitempty"`
	Meta                 *[]byte      `protobuf:"bytes,6,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	Hold                 bool         `protobuf:"varint,7,opt,name=hold,proto3" json:"hold,omitempty"`
	HoldAccId            *int64       `protobuf:"bytes,8,opt,name=hold_acc_id,json=holdAccId,proto3,wktptr" json:"hold_acc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AddTransactionToInvoiceRequest_Oper) Reset()         { *m = AddTransactionToInvoiceRequest_Oper{} }
func (m *AddTransactionToInvoiceRequest_Oper) String() string { return proto.CompactTextString(m) }
func (*AddTransactionToInvoiceRequest_Oper) ProtoMessage()    {}
func (*AddTransactionToInvoiceRequest_Oper) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{4, 0}
}
func (m *AddTransactionToInvoiceRequest_Oper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTransactionToInvoiceRequest_Oper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTransactionToInvoiceRequest_Oper.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTransactionToInvoiceRequest_Oper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTransactionToInvoiceRequest_Oper.Merge(m, src)
}
func (m *AddTransactionToInvoiceRequest_Oper) XXX_Size() int {
	return m.Size()
}
func (m *AddTransactionToInvoiceRequest_Oper) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTransactionToInvoiceRequest_Oper.DiscardUnknown(m)
}

var xxx_messageInfo_AddTransactionToInvoiceRequest_Oper proto.InternalMessageInfo

func (m *AddTransactionToInvoiceRequest_Oper) GetSrcAccId() int64 {
	if m != nil {
		return m.SrcAccId
	}
	return 0
}

func (m *AddTransactionToInvoiceRequest_Oper) GetDstAccId() int64 {
	if m != nil {
		return m.DstAccId
	}
	return 0
}

func (m *AddTransactionToInvoiceRequest_Oper) GetStrategy() OperStrategy {
	if m != nil {
		return m.Strategy
	}
	return OperStrategy_UNKNOW_OPS
}

func (m *AddTransactionToInvoiceRequest_Oper) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *AddTransactionToInvoiceRequest_Oper) GetKey() *string {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AddTransactionToInvoiceRequest_Oper) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AddTransactionToInvoiceRequest_Oper) GetHold() bool {
	if m != nil {
		return m.Hold
	}
	return false
}

func (m *AddTransactionToInvoiceRequest_Oper) GetHoldAccId() *int64 {
	if m != nil {
		return m.HoldAccId
	}
	return nil
}

type AddTransactionToInvoiceResponse struct {
	TxId                 int64    `protobuf:"varint,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddTransactionToInvoiceResponse) Reset()         { *m = AddTransactionToInvoiceResponse{} }
func (m *AddTransactionToInvoiceResponse) String() string { return proto.CompactTextString(m) }
func (*AddTransactionToInvoiceResponse) ProtoMessage()    {}
func (*AddTransactionToInvoiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{5}
}
func (m *AddTransactionToInvoiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTransactionToInvoiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTransactionToInvoiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTransactionToInvoiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTransactionToInvoiceResponse.Merge(m, src)
}
func (m *AddTransactionToInvoiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddTransactionToInvoiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTransactionToInvoiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTransactionToInvoiceResponse proto.InternalMessageInfo

func (m *AddTransactionToInvoiceResponse) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

type GetTransactionByIDsRequest struct {
	TxIds                []int64  `protobuf:"varint,1,rep,packed,name=tx_ids,json=txIds,proto3" json:"tx_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionByIDsRequest) Reset()         { *m = GetTransactionByIDsRequest{} }
func (m *GetTransactionByIDsRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionByIDsRequest) ProtoMessage()    {}
func (*GetTransactionByIDsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{6}
}
func (m *GetTransactionByIDsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionByIDsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionByIDsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionByIDsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionByIDsRequest.Merge(m, src)
}
func (m *GetTransactionByIDsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionByIDsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionByIDsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionByIDsRequest proto.InternalMessageInfo

func (m *GetTransactionByIDsRequest) GetTxIds() []int64 {
	if m != nil {
		return m.TxIds
	}
	return nil
}

type GetTransactionByIDsResponse struct {
	Transactions         []*Tx    `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionByIDsResponse) Reset()         { *m = GetTransactionByIDsResponse{} }
func (m *GetTransactionByIDsResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransactionByIDsResponse) ProtoMessage()    {}
func (*GetTransactionByIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{7}
}
func (m *GetTransactionByIDsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionByIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionByIDsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionByIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionByIDsResponse.Merge(m, src)
}
func (m *GetTransactionByIDsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionByIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionByIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionByIDsResponse proto.InternalMessageInfo

func (m *GetTransactionByIDsResponse) GetTransactions() []*Tx {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type AuthInvoiceRequest struct {
	InvoiceId            int64    `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInvoiceRequest) Reset()         { *m = AuthInvoiceRequest{} }
func (m *AuthInvoiceRequest) String() string { return proto.CompactTextString(m) }
func (*AuthInvoiceRequest) ProtoMessage()    {}
func (*AuthInvoiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{8}
}
func (m *AuthInvoiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthInvoiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthInvoiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthInvoiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInvoiceRequest.Merge(m, src)
}
func (m *AuthInvoiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthInvoiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInvoiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInvoiceRequest proto.InternalMessageInfo

func (m *AuthInvoiceRequest) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

type AuthInvoiceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInvoiceResponse) Reset()         { *m = AuthInvoiceResponse{} }
func (m *AuthInvoiceResponse) String() string { return proto.CompactTextString(m) }
func (*AuthInvoiceResponse) ProtoMessage()    {}
func (*AuthInvoiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{9}
}
func (m *AuthInvoiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthInvoiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthInvoiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthInvoiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInvoiceResponse.Merge(m, src)
}
func (m *AuthInvoiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthInvoiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInvoiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInvoiceResponse proto.InternalMessageInfo

type AcceptInvoiceRequest struct {
	InvoiceId            int64    `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptInvoiceRequest) Reset()         { *m = AcceptInvoiceRequest{} }
func (m *AcceptInvoiceRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptInvoiceRequest) ProtoMessage()    {}
func (*AcceptInvoiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{10}
}
func (m *AcceptInvoiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptInvoiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptInvoiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptInvoiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptInvoiceRequest.Merge(m, src)
}
func (m *AcceptInvoiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptInvoiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptInvoiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptInvoiceRequest proto.InternalMessageInfo

func (m *AcceptInvoiceRequest) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

type AcceptInvoiceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptInvoiceResponse) Reset()         { *m = AcceptInvoiceResponse{} }
func (m *AcceptInvoiceResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptInvoiceResponse) ProtoMessage()    {}
func (*AcceptInvoiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{11}
}
func (m *AcceptInvoiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptInvoiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptInvoiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptInvoiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptInvoiceResponse.Merge(m, src)
}
func (m *AcceptInvoiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptInvoiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptInvoiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptInvoiceResponse proto.InternalMessageInfo

type RejectInvoiceRequest struct {
	InvoiceId            int64    `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectInvoiceRequest) Reset()         { *m = RejectInvoiceRequest{} }
func (m *RejectInvoiceRequest) String() string { return proto.CompactTextString(m) }
func (*RejectInvoiceRequest) ProtoMessage()    {}
func (*RejectInvoiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{12}
}
func (m *RejectInvoiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectInvoiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectInvoiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectInvoiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectInvoiceRequest.Merge(m, src)
}
func (m *RejectInvoiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *RejectInvoiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectInvoiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RejectInvoiceRequest proto.InternalMessageInfo

func (m *RejectInvoiceRequest) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

type RejectInvoiceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectInvoiceResponse) Reset()         { *m = RejectInvoiceResponse{} }
func (m *RejectInvoiceResponse) String() string { return proto.CompactTextString(m) }
func (*RejectInvoiceResponse) ProtoMessage()    {}
func (*RejectInvoiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{13}
}
func (m *RejectInvoiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectInvoiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectInvoiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectInvoiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectInvoiceResponse.Merge(m, src)
}
func (m *RejectInvoiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *RejectInvoiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectInvoiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RejectInvoiceResponse proto.InternalMessageInfo

type AuthTxRequest struct {
	TxId                 int64    `protobuf:"varint,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthTxRequest) Reset()         { *m = AuthTxRequest{} }
func (m *AuthTxRequest) String() string { return proto.CompactTextString(m) }
func (*AuthTxRequest) ProtoMessage()    {}
func (*AuthTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{14}
}
func (m *AuthTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthTxRequest.Merge(m, src)
}
func (m *AuthTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthTxRequest proto.InternalMessageInfo

func (m *AuthTxRequest) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

type AuthTxResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthTxResponse) Reset()         { *m = AuthTxResponse{} }
func (m *AuthTxResponse) String() string { return proto.CompactTextString(m) }
func (*AuthTxResponse) ProtoMessage()    {}
func (*AuthTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{15}
}
func (m *AuthTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthTxResponse.Merge(m, src)
}
func (m *AuthTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthTxResponse proto.InternalMessageInfo

type AcceptTxRequest struct {
	TxId                 int64    `protobuf:"varint,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptTxRequest) Reset()         { *m = AcceptTxRequest{} }
func (m *AcceptTxRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptTxRequest) ProtoMessage()    {}
func (*AcceptTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{16}
}
func (m *AcceptTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTxRequest.Merge(m, src)
}
func (m *AcceptTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTxRequest proto.InternalMessageInfo

func (m *AcceptTxRequest) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

type AcceptTxResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptTxResponse) Reset()         { *m = AcceptTxResponse{} }
func (m *AcceptTxResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptTxResponse) ProtoMessage()    {}
func (*AcceptTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{17}
}
func (m *AcceptTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptTxResponse.Merge(m, src)
}
func (m *AcceptTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptTxResponse proto.InternalMessageInfo

type RejectTxRequest struct {
	TxId                 int64    `protobuf:"varint,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectTxRequest) Reset()         { *m = RejectTxRequest{} }
func (m *RejectTxRequest) String() string { return proto.CompactTextString(m) }
func (*RejectTxRequest) ProtoMessage()    {}
func (*RejectTxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{18}
}
func (m *RejectTxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectTxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectTxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectTxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectTxRequest.Merge(m, src)
}
func (m *RejectTxRequest) XXX_Size() int {
	return m.Size()
}
func (m *RejectTxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectTxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RejectTxRequest proto.InternalMessageInfo

func (m *RejectTxRequest) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

type RejectTxResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectTxResponse) Reset()         { *m = RejectTxResponse{} }
func (m *RejectTxResponse) String() string { return proto.CompactTextString(m) }
func (*RejectTxResponse) ProtoMessage()    {}
func (*RejectTxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cb5cd525462a080, []int{19}
}
func (m *RejectTxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RejectTxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RejectTxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RejectTxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectTxResponse.Merge(m, src)
}
func (m *RejectTxResponse) XXX_Size() int {
	return m.Size()
}
func (m *RejectTxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectTxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RejectTxResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*NewInvoiceRequest)(nil), "api.NewInvoiceRequest")
	proto.RegisterType((*NewInvoiceResponse)(nil), "api.NewInvoiceResponse")
	proto.RegisterType((*GetInvoiceByIDsRequest)(nil), "api.GetInvoiceByIDsRequest")
	proto.RegisterType((*GetInvoiceByIDsResponse)(nil), "api.GetInvoiceByIDsResponse")
	proto.RegisterType((*GetInvoiceByIDsResponse_Invoice)(nil), "api.GetInvoiceByIDsResponse.Invoice")
	proto.RegisterType((*AddTransactionToInvoiceRequest)(nil), "api.AddTransactionToInvoiceRequest")
	proto.RegisterType((*AddTransactionToInvoiceRequest_Oper)(nil), "api.AddTransactionToInvoiceRequest.Oper")
	proto.RegisterType((*AddTransactionToInvoiceResponse)(nil), "api.AddTransactionToInvoiceResponse")
	proto.RegisterType((*GetTransactionByIDsRequest)(nil), "api.GetTransactionByIDsRequest")
	proto.RegisterType((*GetTransactionByIDsResponse)(nil), "api.GetTransactionByIDsResponse")
	proto.RegisterType((*AuthInvoiceRequest)(nil), "api.AuthInvoiceRequest")
	proto.RegisterType((*AuthInvoiceResponse)(nil), "api.AuthInvoiceResponse")
	proto.RegisterType((*AcceptInvoiceRequest)(nil), "api.AcceptInvoiceRequest")
	proto.RegisterType((*AcceptInvoiceResponse)(nil), "api.AcceptInvoiceResponse")
	proto.RegisterType((*RejectInvoiceRequest)(nil), "api.RejectInvoiceRequest")
	proto.RegisterType((*RejectInvoiceResponse)(nil), "api.RejectInvoiceResponse")
	proto.RegisterType((*AuthTxRequest)(nil), "api.AuthTxRequest")
	proto.RegisterType((*AuthTxResponse)(nil), "api.AuthTxResponse")
	proto.RegisterType((*AcceptTxRequest)(nil), "api.AcceptTxRequest")
	proto.RegisterType((*AcceptTxResponse)(nil), "api.AcceptTxResponse")
	proto.RegisterType((*RejectTxRequest)(nil), "api.RejectTxRequest")
	proto.RegisterType((*RejectTxResponse)(nil), "api.RejectTxResponse")
}

func init() { proto.RegisterFile("api/invoice.proto", fileDescriptor_3cb5cd525462a080) }

var fileDescriptor_3cb5cd525462a080 = []byte{
	// 951 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x6b, 0x27, 0x75, 0x4e, 0xd8, 0x6e, 0x3a, 0xdd, 0x36, 0xc1, 0x2d, 0x49, 0x65, 0x2a,
	0x54, 0x81, 0xd6, 0x95, 0x92, 0xdd, 0x95, 0xb8, 0x82, 0x44, 0x48, 0xbb, 0xe1, 0x62, 0x91, 0xdc,
	0x88, 0x0b, 0x6e, 0xa2, 0xa9, 0x3d, 0x9b, 0x1a, 0x9a, 0xd8, 0x78, 0x26, 0x34, 0x7d, 0x0b, 0x5e,
	0x00, 0x89, 0xc7, 0xe0, 0x11, 0xb8, 0x41, 0xe2, 0x0d, 0x40, 0xe5, 0x2d, 0xe0, 0x06, 0x79, 0x7e,
	0x6c, 0xc7, 0x89, 0xdb, 0x66, 0xaf, 0xec, 0x39, 0xe7, 0x7c, 0xdf, 0xf9, 0x9f, 0x81, 0x3d, 0x1c,
	0x05, 0xe7, 0xc1, 0xec, 0xa7, 0x30, 0xf0, 0x88, 0x13, 0xc5, 0x21, 0x0b, 0x91, 0x8e, 0xa3, 0xc0,
	0x6a, 0x24, 0xf2, 0x69, 0xe8, 0x93, 0x6b, 0x2a, 0xc4, 0xd6, 0xf3, 0x49, 0xc0, 0xae, 0xe6, 0x97,
	0x8e, 0x17, 0x4e, 0xcf, 0x27, 0xe1, 0x24, 0x3c, 0xe7, 0xe2, 0xcb, 0xf9, 0x3b, 0x7e, 0xe2, 0x07,
	0xfe, 0x27, 0xcd, 0xdb, 0x93, 0x30, 0x9c, 0x5c, 0x93, 0xcc, 0xea, 0x26, 0xc6, 0x51, 0x44, 0x62,
	0x45, 0xd7, 0x29, 0xea, 0x59, 0x30, 0x25, 0x94, 0xe1, 0x69, 0x24, 0x0c, 0xec, 0x05, 0xec, 0xbd,
	0x25, 0x37, 0x43, 0x11, 0x9a, 0x4b, 0x7e, 0x9c, 0x13, 0xca, 0x50, 0x03, 0xf4, 0x1f, 0xc8, 0x6d,
	0x4b, 0x3b, 0xd1, 0xce, 0x6a, 0x6e, 0xf2, 0x8b, 0x2c, 0x30, 0x29, 0x8b, 0x31, 0x23, 0x93, 0xdb,
	0xd6, 0x36, 0x17, 0xa7, 0x67, 0xf4, 0x12, 0x8c, 0x29, 0x61, 0xb8, 0xa5, 0x9f, 0x68, 0x67, 0xf5,
	0xee, 0x91, 0x23, 0x5c, 0x3a, 0xca, 0xa5, 0x33, 0xb8, 0x65, 0x84, 0x7e, 0x8b, 0xaf, 0xe7, 0x64,
	0x60, 0xfc, 0xfa, 0x57, 0x47, 0x73, 0xb9, 0xb9, 0xdd, 0x03, 0x94, 0xf7, 0x4c, 0xa3, 0x70, 0x46,
	0x09, 0xfa, 0x08, 0x40, 0xd6, 0x69, 0x1c, 0xf8, 0x3c, 0x02, 0xdd, 0xad, 0x49, 0xc9, 0xd0, 0xb7,
	0x5d, 0x38, 0x7c, 0x4d, 0x98, 0x04, 0x0d, 0x6e, 0x87, 0x5f, 0x51, 0x15, 0x73, 0x07, 0xea, 0x19,
	0x90, 0xb6, 0xb4, 0x13, 0xfd, 0x4c, 0x77, 0x21, 0x45, 0x52, 0xd4, 0x84, 0x9d, 0x9b, 0x80, 0x5d,
	0x8d, 0xd9, 0x82, 0x67, 0x60, 0xba, 0xd5, 0xe4, 0x38, 0x5a, 0xd8, 0xff, 0xe9, 0xd0, 0x5c, 0x21,
	0x95, 0xe1, 0x7c, 0x09, 0xa6, 0xa4, 0x10, 0x94, 0xf5, 0xee, 0xa9, 0x83, 0xa3, 0xc0, 0x29, 0xb1,
	0x77, 0x54, 0x3a, 0x29, 0xca, 0xfa, 0x45, 0x87, 0x1d, 0x29, 0x7d, 0x20, 0x39, 0x55, 0xf6, 0xed,
	0xac, 0xec, 0x9f, 0x42, 0x95, 0x32, 0xcc, 0xe6, 0x94, 0x17, 0x77, 0xb7, 0x8b, 0xb8, 0x73, 0x49,
	0x77, 0xc1, 0x35, 0xae, 0xb4, 0x40, 0x3d, 0xa8, 0xcf, 0xc8, 0x82, 0x8d, 0x25, 0xc0, 0x28, 0x05,
	0x40, 0x62, 0x26, 0xfe, 0x97, 0xfa, 0x5a, 0x29, 0xe9, 0x6b, 0x75, 0xa3, 0xbe, 0xa2, 0x2f, 0x00,
	0xbc, 0x98, 0x60, 0x46, 0xfc, 0x31, 0x66, 0xad, 0x1d, 0x0e, 0xb6, 0x56, 0xc0, 0x23, 0x35, 0x87,
	0x03, 0xe3, 0xe7, 0x04, 0x5b, 0x93, 0x98, 0x3e, 0x4b, 0x08, 0xe6, 0x91, 0xaf, 0x08, 0xcc, 0xc7,
	0x12, 0x48, 0x4c, 0x9f, 0xa1, 0xcf, 0xe0, 0x03, 0x16, 0xe3, 0x19, 0xc5, 0x1e, 0x0b, 0xc2, 0x19,
	0x6d, 0xd5, 0x78, 0xe3, 0x76, 0x78, 0x29, 0x46, 0x0b, 0x77, 0x49, 0x69, 0xff, 0x6b, 0x40, 0xbb,
	0xef, 0xfb, 0xa3, 0x4c, 0x36, 0x0a, 0x0b, 0xeb, 0xf0, 0x40, 0xdb, 0x5e, 0x64, 0x6d, 0xab, 0x77,
	0x8f, 0x57, 0x02, 0xbd, 0x60, 0x71, 0x30, 0x9b, 0xe4, 0xeb, 0xb4, 0xb2, 0x51, 0x7a, 0x49, 0xe5,
	0x8d, 0xcd, 0x2a, 0xff, 0x06, 0x20, 0x8c, 0x48, 0x8c, 0x45, 0xd6, 0x15, 0x9e, 0xf5, 0x19, 0xcf,
	0xfa, 0xfe, 0x04, 0x9d, 0x6f, 0x22, 0x12, 0xbb, 0x39, 0x2c, 0x3a, 0x84, 0x2a, 0x9e, 0x86, 0xf3,
	0x19, 0xe3, 0xcd, 0xd7, 0x5d, 0x79, 0xb2, 0xfe, 0xd8, 0x06, 0x23, 0x31, 0x46, 0xc7, 0x00, 0x34,
	0xf6, 0xc6, 0xd8, 0xf3, 0xb2, 0x92, 0x98, 0x34, 0xf6, 0xfa, 0x9e, 0x37, 0xf4, 0x13, 0xad, 0x4f,
	0x99, 0xd2, 0x6e, 0x0b, 0xad, 0x4f, 0x99, 0xd0, 0x3e, 0x2f, 0x64, 0xbe, 0xdb, 0xdd, 0xe3, 0x41,
	0x26, 0xc4, 0x17, 0x52, 0x91, 0x2b, 0x46, 0x16, 0x8b, 0x91, 0x8f, 0x45, 0x95, 0xbd, 0xb2, 0x59,
	0xd9, 0xdf, 0x73, 0xa8, 0x11, 0x18, 0x57, 0xe1, 0xb5, 0xcf, 0xc7, 0xd9, 0x74, 0xf9, 0x3f, 0xea,
	0x43, 0x3d, 0xf9, 0xaa, 0x34, 0xcd, 0x12, 0xc6, 0xe1, 0x8c, 0xbd, 0x7a, 0x91, 0x67, 0xac, 0x25,
	0x28, 0x5e, 0x0a, 0xfb, 0x15, 0x74, 0x4a, 0x5b, 0x23, 0x6f, 0xa0, 0x7d, 0xa8, 0xb0, 0x45, 0x56,
	0x64, 0x83, 0x2d, 0x86, 0xbe, 0xdd, 0x03, 0xeb, 0x35, 0x61, 0x39, 0xdc, 0xd2, 0x55, 0x78, 0x00,
	0x55, 0x0e, 0x51, 0xb7, 0x60, 0x25, 0xc1, 0x50, 0xfb, 0x6b, 0x38, 0x5a, 0x0b, 0x92, 0x8e, 0x8a,
	0x5b, 0xa3, 0xdd, 0xb7, 0x35, 0x3d, 0x40, 0xfd, 0x39, 0xbb, 0xda, 0x68, 0x51, 0xec, 0x03, 0xd8,
	0x5f, 0x02, 0x09, 0xc7, 0xf6, 0x4b, 0x78, 0xd6, 0xf7, 0x3c, 0x12, 0xb1, 0xcd, 0xd8, 0x9a, 0x70,
	0x50, 0x80, 0x65, 0x7c, 0x2e, 0xf9, 0x9e, 0x78, 0x9b, 0xf3, 0x15, 0x60, 0x92, 0xef, 0x14, 0x9e,
	0x24, 0x61, 0x8f, 0x16, 0x8a, 0x68, 0x6d, 0x4b, 0x1a, 0xb0, 0xab, 0xac, 0x24, 0xee, 0x13, 0x78,
	0x2a, 0x02, 0x7c, 0x00, 0x89, 0xa0, 0x91, 0xd9, 0x65, 0x58, 0x11, 0xcc, 0xc3, 0xd8, 0xcc, 0x4e,
	0x60, 0xbb, 0x77, 0x15, 0x30, 0x65, 0x0e, 0x34, 0xb9, 0x4c, 0xb3, 0x57, 0x16, 0x1d, 0xf2, 0x6e,
	0xae, 0x3c, 0xf8, 0x56, 0x73, 0x45, 0x2e, 0xe3, 0xd8, 0x42, 0x6f, 0xe1, 0x69, 0xe1, 0xb1, 0x43,
	0x47, 0xeb, 0x9f, 0x40, 0x41, 0x75, 0x7c, 0xdf, 0xfb, 0x68, 0x6f, 0xa1, 0x77, 0xd0, 0x2c, 0x19,
	0x79, 0xf4, 0xf1, 0x23, 0xee, 0x2a, 0xeb, 0xf4, 0x7e, 0xa3, 0xd4, 0xcf, 0x77, 0xb0, 0xbf, 0x66,
	0xda, 0x51, 0x47, 0x85, 0x57, 0xb2, 0x3c, 0xd6, 0x49, 0xb9, 0x41, 0xca, 0x3d, 0x80, 0x7a, 0x6e,
	0x90, 0x91, 0xa8, 0xde, 0xea, 0x3e, 0x58, 0xad, 0x55, 0x45, 0xca, 0xf1, 0x06, 0x9e, 0x2c, 0x8d,
	0x2f, 0xfa, 0x50, 0x18, 0xaf, 0xd9, 0x04, 0xcb, 0x5a, 0xa7, 0xca, 0x33, 0x2d, 0x0d, 0xae, 0x64,
	0x5a, 0xb7, 0x03, 0x92, 0x69, 0xfd, 0x9c, 0x6f, 0xa1, 0x1e, 0x54, 0xc5, 0x0c, 0x23, 0x94, 0x46,
	0x9e, 0x0e, 0xa0, 0xb5, 0xbf, 0x24, 0x4b, 0x41, 0x9f, 0x83, 0xa9, 0xc6, 0x17, 0x3d, 0xcb, 0x05,
	0x9a, 0x01, 0x0f, 0x0a, 0xd2, 0x3c, 0x54, 0x4d, 0xaf, 0x84, 0x16, 0x86, 0x5e, 0x42, 0x8b, 0x23,
	0x6e, 0x6f, 0x0d, 0x1a, 0xbf, 0xdf, 0xb5, 0xb5, 0x3f, 0xef, 0xda, 0xda, 0xdf, 0x77, 0x6d, 0xed,
	0xb7, 0x7f, 0xda, 0xda, 0x65, 0x95, 0xdf, 0xb8, 0xbd, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x93,
	0x1f, 0x67, 0x45, 0x6c, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InvoicesClient is the client API for Invoices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InvoicesClient interface {
	// NewInvoice создает счет.
	//
	// Errors:
	//   - Common errors
	//   - 3 (InvalidArgument) "Meta is not validate."
	//   - 5 (NotFound) "Strategy is not found."
	NewInvoice(ctx context.Context, in *NewInvoiceRequest, opts ...grpc.CallOption) (*NewInvoiceResponse, error)
	// GetInvoiceByIDs получить список счетов по его идентификаторами.
	//
	// Errors:
	//   - Common errors
	GetInvoiceByIDs(ctx context.Context, in *GetInvoiceByIDsRequest, opts ...grpc.CallOption) (*GetInvoiceByIDsResponse, error)
	// AddTransactionToInvoice добавить транзакцию в счет.
	//
	// Errors:
	//   - Common errors
	//   - 3 (InvalidArgument) "Meta is not validate."
	//   - 5 (NotFound) "Invoice is not found."
	//   - 5 (NotFound) "Strategy is not found."
	AddTransactionToInvoice(ctx context.Context, in *AddTransactionToInvoiceRequest, opts ...grpc.CallOption) (*AddTransactionToInvoiceResponse, error)
	// GetTransactionByIDs получить список транзакций по их идентификаторам.
	//
	// Errors:
	//   - Common errors
	GetTransactionByIDs(ctx context.Context, in *GetTransactionByIDsRequest, opts ...grpc.CallOption) (*GetTransactionByIDsResponse, error)
	// AuthInvoice авторизировать счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	AuthInvoice(ctx context.Context, in *AuthInvoiceRequest, opts ...grpc.CallOption) (*AuthInvoiceResponse, error)
	// AcceptInvoice подтвердить счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	AcceptInvoice(ctx context.Context, in *AcceptInvoiceRequest, opts ...grpc.CallOption) (*AcceptInvoiceResponse, error)
	// RejectInvoice отменить счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	RejectInvoice(ctx context.Context, in *RejectInvoiceRequest, opts ...grpc.CallOption) (*RejectInvoiceResponse, error)
	// AuthTx авторизировать транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	AuthTx(ctx context.Context, in *AuthTxRequest, opts ...grpc.CallOption) (*AuthTxResponse, error)
	// AcceptTx подтвердить транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	AcceptTx(ctx context.Context, in *AcceptTxRequest, opts ...grpc.CallOption) (*AcceptTxResponse, error)
	// RejectTx отменить транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	RejectTx(ctx context.Context, in *RejectTxRequest, opts ...grpc.CallOption) (*RejectTxResponse, error)
}

type invoicesClient struct {
	cc *grpc.ClientConn
}

func NewInvoicesClient(cc *grpc.ClientConn) InvoicesClient {
	return &invoicesClient{cc}
}

func (c *invoicesClient) NewInvoice(ctx context.Context, in *NewInvoiceRequest, opts ...grpc.CallOption) (*NewInvoiceResponse, error) {
	out := new(NewInvoiceResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/NewInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) GetInvoiceByIDs(ctx context.Context, in *GetInvoiceByIDsRequest, opts ...grpc.CallOption) (*GetInvoiceByIDsResponse, error) {
	out := new(GetInvoiceByIDsResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/GetInvoiceByIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) AddTransactionToInvoice(ctx context.Context, in *AddTransactionToInvoiceRequest, opts ...grpc.CallOption) (*AddTransactionToInvoiceResponse, error) {
	out := new(AddTransactionToInvoiceResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/AddTransactionToInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) GetTransactionByIDs(ctx context.Context, in *GetTransactionByIDsRequest, opts ...grpc.CallOption) (*GetTransactionByIDsResponse, error) {
	out := new(GetTransactionByIDsResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/GetTransactionByIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) AuthInvoice(ctx context.Context, in *AuthInvoiceRequest, opts ...grpc.CallOption) (*AuthInvoiceResponse, error) {
	out := new(AuthInvoiceResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/AuthInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) AcceptInvoice(ctx context.Context, in *AcceptInvoiceRequest, opts ...grpc.CallOption) (*AcceptInvoiceResponse, error) {
	out := new(AcceptInvoiceResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/AcceptInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) RejectInvoice(ctx context.Context, in *RejectInvoiceRequest, opts ...grpc.CallOption) (*RejectInvoiceResponse, error) {
	out := new(RejectInvoiceResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/RejectInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) AuthTx(ctx context.Context, in *AuthTxRequest, opts ...grpc.CallOption) (*AuthTxResponse, error) {
	out := new(AuthTxResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/AuthTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) AcceptTx(ctx context.Context, in *AcceptTxRequest, opts ...grpc.CallOption) (*AcceptTxResponse, error) {
	out := new(AcceptTxResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/AcceptTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) RejectTx(ctx context.Context, in *RejectTxRequest, opts ...grpc.CallOption) (*RejectTxResponse, error) {
	out := new(RejectTxResponse)
	err := c.cc.Invoke(ctx, "/api.Invoices/RejectTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InvoicesServer is the server API for Invoices service.
type InvoicesServer interface {
	// NewInvoice создает счет.
	//
	// Errors:
	//   - Common errors
	//   - 3 (InvalidArgument) "Meta is not validate."
	//   - 5 (NotFound) "Strategy is not found."
	NewInvoice(context.Context, *NewInvoiceRequest) (*NewInvoiceResponse, error)
	// GetInvoiceByIDs получить список счетов по его идентификаторами.
	//
	// Errors:
	//   - Common errors
	GetInvoiceByIDs(context.Context, *GetInvoiceByIDsRequest) (*GetInvoiceByIDsResponse, error)
	// AddTransactionToInvoice добавить транзакцию в счет.
	//
	// Errors:
	//   - Common errors
	//   - 3 (InvalidArgument) "Meta is not validate."
	//   - 5 (NotFound) "Invoice is not found."
	//   - 5 (NotFound) "Strategy is not found."
	AddTransactionToInvoice(context.Context, *AddTransactionToInvoiceRequest) (*AddTransactionToInvoiceResponse, error)
	// GetTransactionByIDs получить список транзакций по их идентификаторам.
	//
	// Errors:
	//   - Common errors
	GetTransactionByIDs(context.Context, *GetTransactionByIDsRequest) (*GetTransactionByIDsResponse, error)
	// AuthInvoice авторизировать счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	AuthInvoice(context.Context, *AuthInvoiceRequest) (*AuthInvoiceResponse, error)
	// AcceptInvoice подтвердить счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	AcceptInvoice(context.Context, *AcceptInvoiceRequest) (*AcceptInvoiceResponse, error)
	// RejectInvoice отменить счет.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Invoice is not found."
	RejectInvoice(context.Context, *RejectInvoiceRequest) (*RejectInvoiceResponse, error)
	// AuthTx авторизировать транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	AuthTx(context.Context, *AuthTxRequest) (*AuthTxResponse, error)
	// AcceptTx подтвердить транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	AcceptTx(context.Context, *AcceptTxRequest) (*AcceptTxResponse, error)
	// RejectTx отменить транзакцию.
	//
	// Errors:
	//   - Common errors
	//   - 5 (NotFound) "Transaction is not found."
	RejectTx(context.Context, *RejectTxRequest) (*RejectTxResponse, error)
}

func RegisterInvoicesServer(s *grpc.Server, srv InvoicesServer) {
	s.RegisterService(&_Invoices_serviceDesc, srv)
}

func _Invoices_NewInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).NewInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/NewInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).NewInvoice(ctx, req.(*NewInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_GetInvoiceByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInvoiceByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).GetInvoiceByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/GetInvoiceByIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).GetInvoiceByIDs(ctx, req.(*GetInvoiceByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_AddTransactionToInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTransactionToInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AddTransactionToInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/AddTransactionToInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AddTransactionToInvoice(ctx, req.(*AddTransactionToInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_GetTransactionByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).GetTransactionByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/GetTransactionByIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).GetTransactionByIDs(ctx, req.(*GetTransactionByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_AuthInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AuthInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/AuthInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AuthInvoice(ctx, req.(*AuthInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_AcceptInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AcceptInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/AcceptInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AcceptInvoice(ctx, req.(*AcceptInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_RejectInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).RejectInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/RejectInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).RejectInvoice(ctx, req.(*RejectInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_AuthTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AuthTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/AuthTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AuthTx(ctx, req.(*AuthTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_AcceptTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AcceptTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/AcceptTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AcceptTx(ctx, req.(*AcceptTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_RejectTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).RejectTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Invoices/RejectTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).RejectTx(ctx, req.(*RejectTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Invoices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Invoices",
	HandlerType: (*InvoicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewInvoice",
			Handler:    _Invoices_NewInvoice_Handler,
		},
		{
			MethodName: "GetInvoiceByIDs",
			Handler:    _Invoices_GetInvoiceByIDs_Handler,
		},
		{
			MethodName: "AddTransactionToInvoice",
			Handler:    _Invoices_AddTransactionToInvoice_Handler,
		},
		{
			MethodName: "GetTransactionByIDs",
			Handler:    _Invoices_GetTransactionByIDs_Handler,
		},
		{
			MethodName: "AuthInvoice",
			Handler:    _Invoices_AuthInvoice_Handler,
		},
		{
			MethodName: "AcceptInvoice",
			Handler:    _Invoices_AcceptInvoice_Handler,
		},
		{
			MethodName: "RejectInvoice",
			Handler:    _Invoices_RejectInvoice_Handler,
		},
		{
			MethodName: "AuthTx",
			Handler:    _Invoices_AuthTx_Handler,
		},
		{
			MethodName: "AcceptTx",
			Handler:    _Invoices_AcceptTx_Handler,
		},
		{
			MethodName: "RejectTx",
			Handler:    _Invoices_RejectTx_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/invoice.proto",
}

func (m *NewInvoiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewInvoiceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.Meta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n1, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewInvoiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewInvoiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetInvoiceByIDsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInvoiceByIDsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InvoiceIds) > 0 {
		dAtA3 := make([]byte, len(m.InvoiceIds)*10)
		var j2 int
		for _, num1 := range m.InvoiceIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.WithTx {
		dAtA[i] = 0x10
		i++
		if m.WithTx {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetInvoiceByIDsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInvoiceByIDsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Invoices) > 0 {
		for _, msg := range m.Invoices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInvoice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetInvoiceByIDsResponse_Invoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInvoiceByIDsResponse_Invoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.Status))
	}
	if m.NextStatus != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.NextStatus))
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.Meta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n4, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)))
		n5, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.UpdatedAt != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)))
		n6, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintInvoice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddTransactionToInvoiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTransactionToInvoiceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)))
		n7, err := github_com_gogo_protobuf_types.StdStringMarshalTo(*m.Key, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.Meta != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n8, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Operations) > 0 {
		for _, msg := range m.Operations {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintInvoice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Amount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.Amount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddTransactionToInvoiceRequest_Oper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTransactionToInvoiceRequest_Oper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcAccId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.SrcAccId))
	}
	if m.DstAccId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.DstAccId))
	}
	if m.Strategy != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.Strategy))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.Amount))
	}
	if m.Key != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)))
		n9, err := github_com_gogo_protobuf_types.StdStringMarshalTo(*m.Key, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Meta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n10, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Hold {
		dAtA[i] = 0x38
		i++
		if m.Hold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HoldAccId != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdInt64(*m.HoldAccId)))
		n11, err := github_com_gogo_protobuf_types.StdInt64MarshalTo(*m.HoldAccId, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddTransactionToInvoiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTransactionToInvoiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTransactionByIDsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionByIDsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxIds) > 0 {
		dAtA13 := make([]byte, len(m.TxIds)*10)
		var j12 int
		for _, num1 := range m.TxIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTransactionByIDsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionByIDsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInvoice(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthInvoiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthInvoiceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthInvoiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthInvoiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AcceptInvoiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptInvoiceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AcceptInvoiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptInvoiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RejectInvoiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectInvoiceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RejectInvoiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectInvoiceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthTxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthTxResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AcceptTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AcceptTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptTxResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RejectTxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectTxRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInvoice(dAtA, i, uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RejectTxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RejectTxResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintInvoice(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NewInvoiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewInvoiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetInvoiceByIDsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InvoiceIds) > 0 {
		l = 0
		for _, e := range m.InvoiceIds {
			l += sovInvoice(uint64(e))
		}
		n += 1 + sovInvoice(uint64(l)) + l
	}
	if m.WithTx {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetInvoiceByIDsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Invoices) > 0 {
		for _, e := range m.Invoices {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetInvoiceByIDsResponse_Invoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovInvoice(uint64(m.Status))
	}
	if m.NextStatus != 0 {
		n += 1 + sovInvoice(uint64(m.NextStatus))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddTransactionToInvoiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	if m.Key != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)
		n += 1 + l + sovInvoice(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if len(m.Operations) > 0 {
		for _, e := range m.Operations {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.Amount != 0 {
		n += 1 + sovInvoice(uint64(m.Amount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddTransactionToInvoiceRequest_Oper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcAccId != 0 {
		n += 1 + sovInvoice(uint64(m.SrcAccId))
	}
	if m.DstAccId != 0 {
		n += 1 + sovInvoice(uint64(m.DstAccId))
	}
	if m.Strategy != 0 {
		n += 1 + sovInvoice(uint64(m.Strategy))
	}
	if m.Amount != 0 {
		n += 1 + sovInvoice(uint64(m.Amount))
	}
	if m.Key != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.Hold {
		n += 2
	}
	if m.HoldAccId != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdInt64(*m.HoldAccId)
		n += 1 + l + sovInvoice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddTransactionToInvoiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxId != 0 {
		n += 1 + sovInvoice(uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionByIDsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TxIds) > 0 {
		l = 0
		for _, e := range m.TxIds {
			l += sovInvoice(uint64(e))
		}
		n += 1 + sovInvoice(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionByIDsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovInvoice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthInvoiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthInvoiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcceptInvoiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcceptInvoiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RejectInvoiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovInvoice(uint64(m.InvoiceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RejectInvoiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxId != 0 {
		n += 1 + sovInvoice(uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcceptTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxId != 0 {
		n += 1 + sovInvoice(uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcceptTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RejectTxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxId != 0 {
		n += 1 + sovInvoice(uint64(m.TxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RejectTxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInvoice(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInvoice(x uint64) (n int) {
	return sovInvoice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NewInvoiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewInvoiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewInvoiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewInvoiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewInvoiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewInvoiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceByIDsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceByIDsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceByIDsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InvoiceIds = append(m.InvoiceIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInvoice
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInvoice
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InvoiceIds) == 0 {
					m.InvoiceIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInvoice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InvoiceIds = append(m.InvoiceIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithTx", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithTx = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceByIDsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceByIDsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceByIDsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invoices = append(m.Invoices, &GetInvoiceByIDsResponse_Invoice{})
			if err := m.Invoices[len(m.Invoices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceByIDsResponse_Invoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InvoiceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStatus", wireType)
			}
			m.NextStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStatus |= InvoiceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Tx{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTransactionToInvoiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTransactionToInvoiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTransactionToInvoiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = new(string)
			}
			if err := github_com_gogo_protobuf_types.StdStringUnmarshal(m.Key, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operations = append(m.Operations, &AddTransactionToInvoiceRequest_Oper{})
			if err := m.Operations[len(m.Operations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTransactionToInvoiceRequest_Oper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAccId", wireType)
			}
			m.SrcAccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcAccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAccId", wireType)
			}
			m.DstAccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstAccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= OperStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = new(string)
			}
			if err := github_com_gogo_protobuf_types.StdStringUnmarshal(m.Key, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hold = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldAccId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HoldAccId == nil {
				m.HoldAccId = new(int64)
			}
			if err := github_com_gogo_protobuf_types.StdInt64Unmarshal(m.HoldAccId, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTransactionToInvoiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTransactionToInvoiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTransactionToInvoiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionByIDsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionByIDsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionByIDsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TxIds = append(m.TxIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInvoice
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInvoice
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TxIds) == 0 {
					m.TxIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInvoice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TxIds = append(m.TxIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionByIDsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionByIDsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionByIDsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInvoice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInvoice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Tx{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInvoiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInvoiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInvoiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInvoiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInvoiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInvoiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptInvoiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptInvoiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptInvoiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptInvoiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptInvoiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptInvoiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectInvoiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectInvoiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectInvoiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectInvoiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectInvoiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectInvoiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectTxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectTxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectTxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RejectTxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RejectTxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RejectTxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInvoice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInvoice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInvoice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInvoice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInvoice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInvoice
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInvoice
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInvoice
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInvoice(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInvoice
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInvoice = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInvoice   = fmt.Errorf("proto: integer overflow")
)
