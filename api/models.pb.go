// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/models.proto

package api

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/golang/protobuf/ptypes/wrappers"
	io "io"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type InvoiceStatus int32

const (
	InvoiceStatus_UNKNOWN_I InvoiceStatus = 0
	// DRAFT_I статус инвойса в черновике. В этом статусе позволено
	// вносить изменения в инвойс и входящие в него транзакции.
	// Только в этом статусе позволено вручную менять состав инвойса.
	InvoiceStatus_DRAFT_I InvoiceStatus = 1
	// AUTH_I статус инвойса когда он прошел первичную валидацию и готов к дальнейшей обработке.
	InvoiceStatus_AUTH_I InvoiceStatus = 2
	// WAIT_I статус инвойса в ожидании подтверждения чего либо. Служит для двух-этапных операций.
	InvoiceStatus_WAIT_I InvoiceStatus = 3
	// ACCEPTED_I конечный статус инвойса. Весь инвойс принят и успешно исполнен.
	InvoiceStatus_ACCEPTED_I InvoiceStatus = 4
	// REJECTED_I конечный статус инвойса. Весь инвойс отклонен.
	InvoiceStatus_REJECTED_I InvoiceStatus = 5
)

var InvoiceStatus_name = map[int32]string{
	0: "UNKNOWN_I",
	1: "DRAFT_I",
	2: "AUTH_I",
	3: "WAIT_I",
	4: "ACCEPTED_I",
	5: "REJECTED_I",
}

var InvoiceStatus_value = map[string]int32{
	"UNKNOWN_I":  0,
	"DRAFT_I":    1,
	"AUTH_I":     2,
	"WAIT_I":     3,
	"ACCEPTED_I": 4,
	"REJECTED_I": 5,
}

func (x InvoiceStatus) String() string {
	return proto.EnumName(InvoiceStatus_name, int32(x))
}

func (InvoiceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{0}
}

type TxStatus int32

const (
	TxStatus_UNKNOWN_TX   TxStatus = 0
	TxStatus_DRAFT_TX     TxStatus = 1
	TxStatus_AUTH_TX      TxStatus = 2
	TxStatus_HOLD_TX      TxStatus = 4
	TxStatus_ACCEPTED_TX  TxStatus = 6
	TxStatus_WACCEPTED_TX TxStatus = 7
	TxStatus_REJECTED_TX  TxStatus = 8
	TxStatus_WREJECTED_TX TxStatus = 9
	TxStatus_FAILED_TX    TxStatus = 10
)

var TxStatus_name = map[int32]string{
	0:  "UNKNOWN_TX",
	1:  "DRAFT_TX",
	2:  "AUTH_TX",
	4:  "HOLD_TX",
	6:  "ACCEPTED_TX",
	7:  "WACCEPTED_TX",
	8:  "REJECTED_TX",
	9:  "WREJECTED_TX",
	10: "FAILED_TX",
}

var TxStatus_value = map[string]int32{
	"UNKNOWN_TX":   0,
	"DRAFT_TX":     1,
	"AUTH_TX":      2,
	"HOLD_TX":      4,
	"ACCEPTED_TX":  6,
	"WACCEPTED_TX": 7,
	"REJECTED_TX":  8,
	"WREJECTED_TX": 9,
	"FAILED_TX":    10,
}

func (x TxStatus) String() string {
	return proto.EnumName(TxStatus_name, int32(x))
}

func (TxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{1}
}

type Provider int32

const (
	Provider_UNKNOWN_PROVIDER  Provider = 0
	Provider_INTERNAL_PROVIDER Provider = 1
	Provider_SBERBANK_PROVIDER Provider = 2
)

var Provider_name = map[int32]string{
	0: "UNKNOWN_PROVIDER",
	1: "INTERNAL_PROVIDER",
	2: "SBERBANK_PROVIDER",
}

var Provider_value = map[string]int32{
	"UNKNOWN_PROVIDER":  0,
	"INTERNAL_PROVIDER": 1,
	"SBERBANK_PROVIDER": 2,
}

func (x Provider) String() string {
	return proto.EnumName(Provider_name, int32(x))
}

func (Provider) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{2}
}

type OperStrategy int32

const (
	OperStrategy_UNKNOW_OPS OperStrategy = 0
	// SIMPLE_OPS простой внутренний перевод с SRC->DST
	OperStrategy_SIMPLE_OPS OperStrategy = 1
	// RECHARGE_OPS ввод в систему средст из внешней среду.
	OperStrategy_RECHARGE_OPS OperStrategy = 2
	// WITHDRAW_OPS вывод из системы средств во внешнюю среду.
	OperStrategy_WITHDRAW_OPS OperStrategy = 3
)

var OperStrategy_name = map[int32]string{
	0: "UNKNOW_OPS",
	1: "SIMPLE_OPS",
	2: "RECHARGE_OPS",
	3: "WITHDRAW_OPS",
}

var OperStrategy_value = map[string]int32{
	"UNKNOW_OPS":   0,
	"SIMPLE_OPS":   1,
	"RECHARGE_OPS": 2,
	"WITHDRAW_OPS": 3,
}

func (x OperStrategy) String() string {
	return proto.EnumName(OperStrategy_name, int32(x))
}

func (OperStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{3}
}

type OperStatus int32

const (
	OperStatus_UNKNOWN_OP  OperStatus = 0
	OperStatus_DRAFT_OP    OperStatus = 1
	OperStatus_HOLD_OP     OperStatus = 2
	OperStatus_ACCEPTED_OP OperStatus = 3
	OperStatus_REJECTED_OP OperStatus = 4
)

var OperStatus_name = map[int32]string{
	0: "UNKNOWN_OP",
	1: "DRAFT_OP",
	2: "HOLD_OP",
	3: "ACCEPTED_OP",
	4: "REJECTED_OP",
}

var OperStatus_value = map[string]int32{
	"UNKNOWN_OP":  0,
	"DRAFT_OP":    1,
	"HOLD_OP":     2,
	"ACCEPTED_OP": 3,
	"REJECTED_OP": 4,
}

func (x OperStatus) String() string {
	return proto.EnumName(OperStatus_name, int32(x))
}

func (OperStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{4}
}

type Currency struct {
	CurrId               int64    `protobuf:"varint,1,opt,name=curr_id,json=currId,proto3" json:"curr_id,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Meta                 *[]byte  `protobuf:"bytes,3,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Currency) Reset()         { *m = Currency{} }
func (m *Currency) String() string { return proto.CompactTextString(m) }
func (*Currency) ProtoMessage()    {}
func (*Currency) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{0}
}
func (m *Currency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Currency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Currency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Currency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Currency.Merge(m, src)
}
func (m *Currency) XXX_Size() int {
	return m.Size()
}
func (m *Currency) XXX_DiscardUnknown() {
	xxx_messageInfo_Currency.DiscardUnknown(m)
}

var xxx_messageInfo_Currency proto.InternalMessageInfo

func (m *Currency) GetCurrId() int64 {
	if m != nil {
		return m.CurrId
	}
	return 0
}

func (m *Currency) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Currency) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

type Account struct {
	AccId                int64      `protobuf:"varint,1,opt,name=acc_id,json=accId,proto3" json:"acc_id,omitempty"`
	CurrId               int64      `protobuf:"varint,2,opt,name=curr_id,json=currId,proto3" json:"curr_id,omitempty"`
	Key                  string     `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Balance              int64      `protobuf:"varint,4,opt,name=balance,proto3" json:"balance,omitempty"`
	BalanceAccepted      int64      `protobuf:"varint,5,opt,name=balance_accepted,json=balanceAccepted,proto3" json:"balance_accepted,omitempty"`
	Meta                 *[]byte    `protobuf:"bytes,6,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	CreatedAt            time.Time  `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt            *time.Time `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{1}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetAccId() int64 {
	if m != nil {
		return m.AccId
	}
	return 0
}

func (m *Account) GetCurrId() int64 {
	if m != nil {
		return m.CurrId
	}
	return 0
}

func (m *Account) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Account) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetBalanceAccepted() int64 {
	if m != nil {
		return m.BalanceAccepted
	}
	return 0
}

func (m *Account) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Account) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Account) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

type Invoice struct {
	// invoice_id внутренний идентификатор инвойса.
	InvoiceId int64 `protobuf:"varint,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// key внешний уникальный идентицитора инвойса.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// status состояние инвойса.
	Status InvoiceStatus `protobuf:"varint,3,opt,name=status,proto3,enum=api.InvoiceStatus" json:"status,omitempty"`
	// next_status куда переходит инвойс.
	NextStatus InvoiceStatus `protobuf:"varint,4,opt,name=next_status,json=nextStatus,proto3,enum=api.InvoiceStatus" json:"next_status,omitempty"`
	// strategy стратегия работы с инвойсом.
	Strategy             string     `protobuf:"bytes,5,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Meta                 *[]byte    `protobuf:"bytes,6,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	CreatedAt            *time.Time `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt            *time.Time `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Invoice) Reset()         { *m = Invoice{} }
func (m *Invoice) String() string { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()    {}
func (*Invoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{2}
}
func (m *Invoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Invoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Invoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Invoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Invoice.Merge(m, src)
}
func (m *Invoice) XXX_Size() int {
	return m.Size()
}
func (m *Invoice) XXX_DiscardUnknown() {
	xxx_messageInfo_Invoice.DiscardUnknown(m)
}

var xxx_messageInfo_Invoice proto.InternalMessageInfo

func (m *Invoice) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

func (m *Invoice) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Invoice) GetStatus() InvoiceStatus {
	if m != nil {
		return m.Status
	}
	return InvoiceStatus_UNKNOWN_I
}

func (m *Invoice) GetNextStatus() InvoiceStatus {
	if m != nil {
		return m.NextStatus
	}
	return InvoiceStatus_UNKNOWN_I
}

func (m *Invoice) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *Invoice) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Invoice) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Invoice) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

type Tx struct {
	// tx_id внутренний идентификатор транзакции.
	TxId int64 `protobuf:"varint,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	// invoice_id связанный с транзакцией инвойс.
	InvoiceId int64 `protobuf:"varint,2,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// key Уникальный внешний идентификатор транзакции (опционально).
	Key *string `protobuf:"bytes,3,opt,name=key,proto3,wktptr" json:"key,omitempty"`
	// strategy стратегия работы с инвойсом.
	Strategy string `protobuf:"bytes,4,opt,name=strategy,proto3" json:"strategy,omitempty"`
	// provider Тип провайдера обслуживающий транзакцию.
	Provider Provider `protobuf:"varint,5,opt,name=provider,proto3,enum=api.Provider" json:"provider,omitempty"`
	// provider_oper_id Идентификатор связанной с транзакцией операции во внешней системе.
	ProviderOperId *string `protobuf:"bytes,6,opt,name=provider_oper_id,json=providerOperId,proto3,wktptr" json:"provider_oper_id,omitempty"`
	// provider_oper_status Статус связанной с транзакцией операции во внешней системе.
	ProviderOperStatus *string `protobuf:"bytes,7,opt,name=provider_oper_status,json=providerOperStatus,proto3,wktptr" json:"provider_oper_status,omitempty"`
	Meta               *[]byte `protobuf:"bytes,8,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	// status статус транзакции.
	Status TxStatus `protobuf:"varint,9,opt,name=status,proto3,enum=api.TxStatus" json:"status,omitempty"`
	// next_status статус транзакции куда происходит переход.
	NextStatus           TxStatus   `protobuf:"varint,10,opt,name=next_status,json=nextStatus,proto3,enum=api.TxStatus" json:"next_status,omitempty"`
	CreatedAt            *time.Time `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at,omitempty"`
	UpdatedAt            *time.Time `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{3}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

func (m *Tx) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

func (m *Tx) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

func (m *Tx) GetKey() *string {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Tx) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *Tx) GetProvider() Provider {
	if m != nil {
		return m.Provider
	}
	return Provider_UNKNOWN_PROVIDER
}

func (m *Tx) GetProviderOperId() *string {
	if m != nil {
		return m.ProviderOperId
	}
	return nil
}

func (m *Tx) GetProviderOperStatus() *string {
	if m != nil {
		return m.ProviderOperStatus
	}
	return nil
}

func (m *Tx) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Tx) GetStatus() TxStatus {
	if m != nil {
		return m.Status
	}
	return TxStatus_UNKNOWN_TX
}

func (m *Tx) GetNextStatus() TxStatus {
	if m != nil {
		return m.NextStatus
	}
	return TxStatus_UNKNOWN_TX
}

func (m *Tx) GetCreatedAt() *time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Tx) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

type Oper struct {
	OperId               int64        `protobuf:"varint,1,opt,name=oper_id,json=operId,proto3" json:"oper_id,omitempty"`
	InvoiceId            int64        `protobuf:"varint,2,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	TxId                 int64        `protobuf:"varint,3,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	SrcAccId             int64        `protobuf:"varint,4,opt,name=src_acc_id,json=srcAccId,proto3" json:"src_acc_id,omitempty"`
	Hold                 bool         `protobuf:"varint,5,opt,name=hold,proto3" json:"hold,omitempty"`
	HoldAccId            int64        `protobuf:"varint,6,opt,name=hold_acc_id,json=holdAccId,proto3" json:"hold_acc_id,omitempty"`
	DstAccId             int64        `protobuf:"varint,7,opt,name=dst_acc_id,json=dstAccId,proto3" json:"dst_acc_id,omitempty"`
	Strategy             OperStrategy `protobuf:"varint,8,opt,name=strategy,proto3,enum=api.OperStrategy" json:"strategy,omitempty"`
	Amount               int64        `protobuf:"varint,9,opt,name=amount,proto3" json:"amount,omitempty"`
	Key                  string       `protobuf:"bytes,10,opt,name=key,proto3" json:"key,omitempty"`
	Meta                 *[]byte      `protobuf:"bytes,11,opt,name=meta,proto3,wktptr" json:"meta,omitempty"`
	Status               OperStatus   `protobuf:"varint,12,opt,name=status,proto3,enum=api.OperStatus" json:"status,omitempty"`
	CreatedAt            time.Time    `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt            *time.Time   `protobuf:"bytes,14,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Oper) Reset()         { *m = Oper{} }
func (m *Oper) String() string { return proto.CompactTextString(m) }
func (*Oper) ProtoMessage()    {}
func (*Oper) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc2caa005a711e31, []int{4}
}
func (m *Oper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Oper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Oper.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Oper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Oper.Merge(m, src)
}
func (m *Oper) XXX_Size() int {
	return m.Size()
}
func (m *Oper) XXX_DiscardUnknown() {
	xxx_messageInfo_Oper.DiscardUnknown(m)
}

var xxx_messageInfo_Oper proto.InternalMessageInfo

func (m *Oper) GetOperId() int64 {
	if m != nil {
		return m.OperId
	}
	return 0
}

func (m *Oper) GetInvoiceId() int64 {
	if m != nil {
		return m.InvoiceId
	}
	return 0
}

func (m *Oper) GetTxId() int64 {
	if m != nil {
		return m.TxId
	}
	return 0
}

func (m *Oper) GetSrcAccId() int64 {
	if m != nil {
		return m.SrcAccId
	}
	return 0
}

func (m *Oper) GetHold() bool {
	if m != nil {
		return m.Hold
	}
	return false
}

func (m *Oper) GetHoldAccId() int64 {
	if m != nil {
		return m.HoldAccId
	}
	return 0
}

func (m *Oper) GetDstAccId() int64 {
	if m != nil {
		return m.DstAccId
	}
	return 0
}

func (m *Oper) GetStrategy() OperStrategy {
	if m != nil {
		return m.Strategy
	}
	return OperStrategy_UNKNOW_OPS
}

func (m *Oper) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Oper) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Oper) GetMeta() *[]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Oper) GetStatus() OperStatus {
	if m != nil {
		return m.Status
	}
	return OperStatus_UNKNOWN_OP
}

func (m *Oper) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Oper) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.InvoiceStatus", InvoiceStatus_name, InvoiceStatus_value)
	proto.RegisterEnum("api.TxStatus", TxStatus_name, TxStatus_value)
	proto.RegisterEnum("api.Provider", Provider_name, Provider_value)
	proto.RegisterEnum("api.OperStrategy", OperStrategy_name, OperStrategy_value)
	proto.RegisterEnum("api.OperStatus", OperStatus_name, OperStatus_value)
	proto.RegisterType((*Currency)(nil), "api.Currency")
	proto.RegisterType((*Account)(nil), "api.Account")
	proto.RegisterType((*Invoice)(nil), "api.Invoice")
	proto.RegisterType((*Tx)(nil), "api.Tx")
	proto.RegisterType((*Oper)(nil), "api.Oper")
}

func init() { proto.RegisterFile("api/models.proto", fileDescriptor_bc2caa005a711e31) }

var fileDescriptor_bc2caa005a711e31 = []byte{
	// 991 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xe3, 0x54,
	0x14, 0xae, 0x7f, 0xea, 0x38, 0x27, 0xfd, 0xb9, 0x73, 0x99, 0x81, 0xa8, 0x94, 0xb4, 0xaa, 0x84,
	0xe8, 0x44, 0x9a, 0x54, 0xea, 0xc0, 0x7a, 0xe4, 0xa4, 0x19, 0x6a, 0xa6, 0xc4, 0x96, 0xe3, 0x99,
	0x86, 0x95, 0xe5, 0xda, 0x97, 0x8c, 0x45, 0x12, 0x5b, 0xf6, 0xcd, 0x90, 0xbe, 0x00, 0x6b, 0x76,
	0x6c, 0x79, 0x0c, 0x1e, 0x61, 0x96, 0xf0, 0x02, 0x80, 0xca, 0x8a, 0x1d, 0x8f, 0x80, 0xee, 0xbd,
	0x76, 0xe2, 0xa4, 0x45, 0x34, 0x03, 0xab, 0x9c, 0xff, 0x73, 0xee, 0x77, 0x3e, 0x9f, 0x00, 0xf2,
	0x93, 0xe8, 0x64, 0x1c, 0x87, 0x64, 0x94, 0xb5, 0x92, 0x34, 0xa6, 0x31, 0x56, 0xfc, 0x24, 0xda,
	0x7b, 0x32, 0x8c, 0xe8, 0xeb, 0xe9, 0x55, 0x2b, 0x88, 0xc7, 0x27, 0xc3, 0x78, 0x18, 0x9f, 0x70,
	0xdf, 0xd5, 0xf4, 0x6b, 0xae, 0x71, 0x85, 0x4b, 0x22, 0x67, 0xaf, 0x31, 0x8c, 0xe3, 0xe1, 0x88,
	0x2c, 0xa2, 0xbe, 0x4d, 0xfd, 0x24, 0x21, 0x69, 0x5e, 0x73, 0xef, 0x60, 0xd5, 0x4f, 0xa3, 0x31,
	0xc9, 0xa8, 0x3f, 0x4e, 0x44, 0xc0, 0xd1, 0x08, 0xf4, 0xce, 0x34, 0x4d, 0xc9, 0x24, 0xb8, 0xc6,
	0x1f, 0x40, 0x25, 0x98, 0xa6, 0xa9, 0x17, 0x85, 0x75, 0xe9, 0x50, 0x3a, 0x56, 0x1c, 0x8d, 0xa9,
	0x66, 0x88, 0x11, 0x28, 0xdf, 0x90, 0xeb, 0xba, 0x7c, 0x28, 0x1d, 0x57, 0x1d, 0x26, 0xe2, 0xcf,
	0x40, 0x1d, 0x13, 0xea, 0xd7, 0x95, 0x43, 0xe9, 0xb8, 0x76, 0xfa, 0x61, 0x4b, 0xb4, 0x69, 0x15,
	0x6d, 0x5a, 0xed, 0x6b, 0x4a, 0xb2, 0x57, 0xfe, 0x68, 0x4a, 0xda, 0xea, 0x8f, 0xbf, 0x1d, 0x48,
	0x0e, 0x0f, 0x3f, 0xfa, 0x45, 0x86, 0x8a, 0x11, 0x04, 0xf1, 0x74, 0x42, 0xf1, 0x23, 0xd0, 0xfc,
	0x20, 0x58, 0x34, 0xdb, 0xf4, 0x83, 0xc0, 0x0c, 0xcb, 0x43, 0xc8, 0x77, 0x0d, 0xa1, 0x2c, 0x86,
	0xa8, 0x43, 0xe5, 0xca, 0x1f, 0xf9, 0x93, 0x80, 0xd4, 0x55, 0x1e, 0x5a, 0xa8, 0xf8, 0x31, 0xa0,
	0x5c, 0xf4, 0xfc, 0x20, 0x20, 0x09, 0x25, 0x61, 0x7d, 0x93, 0x87, 0xec, 0xe6, 0x76, 0x23, 0x37,
	0xcf, 0x5f, 0xa2, 0xad, 0xf5, 0x12, 0xdc, 0x01, 0x08, 0x52, 0xe2, 0x53, 0x12, 0x7a, 0x3e, 0xad,
	0x57, 0x78, 0xf2, 0xde, 0xad, 0x64, 0xb7, 0x40, 0xbb, 0xad, 0xbf, 0xfd, 0xf5, 0x60, 0xe3, 0x7b,
	0x96, 0x5f, 0xcd, 0xf3, 0x0c, 0xca, 0x8a, 0x4c, 0x93, 0xb0, 0x28, 0xa2, 0xdf, 0xab, 0x88, 0x24,
	0x8a, 0xe4, 0x79, 0x06, 0x3d, 0xfa, 0x4b, 0x86, 0x8a, 0x39, 0x79, 0x13, 0x47, 0x01, 0xc1, 0x1f,
	0x01, 0x44, 0x42, 0x5c, 0xe0, 0x5a, 0xcd, 0x2d, 0x77, 0xee, 0xb1, 0x09, 0x5a, 0x46, 0x7d, 0x3a,
	0xcd, 0x38, 0xae, 0x3b, 0xa7, 0xb8, 0xe5, 0x27, 0x51, 0x2b, 0x2f, 0xd7, 0xe7, 0x1e, 0x27, 0x8f,
	0xc0, 0x4f, 0xa1, 0x36, 0x21, 0x33, 0xea, 0xe5, 0x09, 0xea, 0x3f, 0x26, 0x00, 0x0b, 0x13, 0x32,
	0xde, 0x03, 0x3d, 0xa3, 0xa9, 0x4f, 0xc9, 0xf0, 0x9a, 0x6f, 0xa0, 0xea, 0xcc, 0xf5, 0x77, 0x85,
	0xfe, 0xd9, 0x9a, 0xd0, 0xab, 0xab, 0xb0, 0x3f, 0x5b, 0x13, 0x76, 0x75, 0x15, 0xf2, 0x3f, 0x55,
	0x90, 0xdd, 0x19, 0x7e, 0x0f, 0x36, 0xe9, 0x6c, 0x01, 0xb4, 0x4a, 0x67, 0x66, 0xb8, 0xb2, 0x02,
	0x79, 0x75, 0x05, 0x9f, 0x2e, 0x58, 0x5c, 0x3b, 0xdd, 0xbf, 0xd5, 0xb4, 0x4f, 0xd3, 0x68, 0x32,
	0x2c, 0xbf, 0x99, 0xaf, 0xa9, 0x8c, 0xa2, 0xba, 0x82, 0xe2, 0x63, 0xd0, 0x93, 0x34, 0x7e, 0x13,
	0x85, 0x24, 0xe5, 0x08, 0xef, 0x9c, 0x6e, 0xf3, 0x9d, 0xd8, 0xb9, 0xd1, 0x99, 0xbb, 0xf1, 0x05,
	0xa0, 0x42, 0xf6, 0xe2, 0x84, 0xf0, 0x8f, 0x4c, 0xbb, 0xf7, 0x24, 0x3b, 0x45, 0xae, 0x95, 0x10,
	0xf6, 0x41, 0xba, 0xf0, 0x70, 0xb9, 0x5a, 0x4e, 0x8c, 0xca, 0xbd, 0x2b, 0xe2, 0x72, 0xc5, 0x9c,
	0x30, 0x05, 0x29, 0xf4, 0xf5, 0x48, 0xf1, 0xf1, 0x9c, 0xc8, 0xd5, 0x12, 0x06, 0xee, 0x6c, 0x85,
	0xc3, 0xad, 0x65, 0x0e, 0xc3, 0x5d, 0xb1, 0x65, 0xfa, 0x2e, 0x73, 0xad, 0xf6, 0x5f, 0xb9, 0xb6,
	0xb5, 0x3e, 0xd7, 0xbe, 0x53, 0x41, 0x65, 0xf0, 0xb0, 0xc3, 0x58, 0xec, 0x2c, 0xbf, 0xce, 0xb1,
	0xd8, 0xc3, 0xbf, 0x30, 0x6e, 0xce, 0x52, 0xa5, 0xc4, 0xd2, 0x7d, 0x80, 0x2c, 0x0d, 0xbc, 0xfc,
	0x00, 0x8b, 0xeb, 0xa9, 0x67, 0x69, 0x60, 0xf0, 0x1b, 0x8c, 0x41, 0x7d, 0x1d, 0x8f, 0xc4, 0xc9,
	0xd4, 0x1d, 0x2e, 0xe3, 0x06, 0xd4, 0xd8, 0x6f, 0x91, 0xa2, 0x89, 0x36, 0xcc, 0x24, 0x72, 0xf6,
	0x01, 0xc2, 0x8c, 0x16, 0xee, 0x8a, 0xa8, 0x18, 0x66, 0x54, 0x78, 0x9f, 0x94, 0x08, 0xac, 0x73,
	0xd0, 0x1f, 0x70, 0xd0, 0xc5, 0xe2, 0x85, 0xa3, 0xc4, 0xe9, 0xf7, 0x41, 0xf3, 0xc7, 0xec, 0x5f,
	0x82, 0x6f, 0x53, 0x71, 0x72, 0xad, 0x38, 0x60, 0x70, 0xfb, 0x8f, 0xa8, 0xb6, 0x1e, 0x5d, 0x3e,
	0x99, 0xd3, 0x65, 0x8b, 0x4f, 0xb3, 0x5b, 0x9a, 0x66, 0x89, 0x30, 0xcb, 0x77, 0x7e, 0xfb, 0xff,
	0xb8, 0xf3, 0x3b, 0xef, 0x74, 0xe7, 0x9b, 0x01, 0x6c, 0x2f, 0x9d, 0x59, 0xbc, 0x0d, 0xd5, 0x97,
	0xbd, 0x17, 0x3d, 0xeb, 0xb2, 0xe7, 0x99, 0x68, 0x03, 0xd7, 0xa0, 0x72, 0xe6, 0x18, 0xcf, 0x5d,
	0xcf, 0x44, 0x12, 0x06, 0xd0, 0x8c, 0x97, 0xee, 0xb9, 0x67, 0x22, 0x99, 0xc9, 0x97, 0x86, 0xc9,
	0xec, 0x0a, 0xde, 0x01, 0x30, 0x3a, 0x9d, 0xae, 0xed, 0x76, 0xcf, 0x3c, 0x13, 0xa9, 0x4c, 0x77,
	0xba, 0x5f, 0x74, 0x3b, 0x42, 0xdf, 0x6c, 0xfe, 0x20, 0x81, 0x5e, 0x7c, 0x08, 0xcc, 0x59, 0x34,
	0x70, 0x07, 0x68, 0x03, 0x6f, 0x81, 0x2e, 0x3a, 0xb8, 0x03, 0x24, 0xb1, 0x7e, 0xbc, 0x85, 0x3b,
	0x40, 0x32, 0x53, 0xce, 0xad, 0x8b, 0x33, 0xa6, 0xa8, 0x78, 0x17, 0x6a, 0xf3, 0x26, 0xee, 0x00,
	0x69, 0x18, 0xc1, 0xd6, 0x65, 0xd9, 0x52, 0x61, 0x21, 0xf3, 0xbe, 0xee, 0x00, 0xe9, 0x3c, 0xa4,
	0x6c, 0xa9, 0xb2, 0xe7, 0x3d, 0x37, 0xcc, 0x0b, 0xa1, 0x42, 0xb3, 0x07, 0x7a, 0x71, 0xd1, 0xf0,
	0x43, 0x40, 0xc5, 0x60, 0xb6, 0x63, 0xbd, 0x32, 0xcf, 0xba, 0x0e, 0xda, 0xc0, 0x8f, 0xe0, 0x81,
	0xd9, 0x73, 0xbb, 0x4e, 0xcf, 0xb8, 0x58, 0x98, 0x25, 0x66, 0xee, 0xb7, 0xbb, 0x4e, 0xdb, 0xe8,
	0xbd, 0x58, 0x98, 0xe5, 0xa6, 0x03, 0x5b, 0x65, 0xf2, 0x2d, 0x1e, 0xeb, 0x59, 0x76, 0x1f, 0x6d,
	0x30, 0xbd, 0x6f, 0x7e, 0x69, 0x5f, 0x74, 0xb9, 0x2e, 0xb1, 0x01, 0x9d, 0x6e, 0xe7, 0xdc, 0x70,
	0x3e, 0x17, 0x16, 0x99, 0x8f, 0x6c, 0xba, 0xe7, 0x67, 0x8e, 0x21, 0x72, 0x94, 0xe6, 0x57, 0x00,
	0xa5, 0x4b, 0x56, 0x82, 0xcf, 0xb2, 0xcb, 0xf0, 0x59, 0xb6, 0x80, 0x8f, 0x23, 0x66, 0xd9, 0x48,
	0x5e, 0x42, 0xcc, 0xb2, 0x91, 0xb2, 0x84, 0x8f, 0x65, 0x23, 0xb5, 0x8d, 0xde, 0xde, 0x34, 0xa4,
	0x9f, 0x6f, 0x1a, 0xd2, 0xef, 0x37, 0x0d, 0xe9, 0xa7, 0x3f, 0x1a, 0xd2, 0x95, 0xc6, 0x89, 0xf3,
	0xf4, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe9, 0x44, 0x52, 0x6e, 0x49, 0x0a, 0x00, 0x00,
}

func (m *Currency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Currency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CurrId))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n1, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.AccId))
	}
	if m.CurrId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CurrId))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Balance != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Balance))
	}
	if m.BalanceAccepted != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.BalanceAccepted))
	}
	if m.Meta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n2, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)))
	n3, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.UpdatedAt != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)))
		n4, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Invoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Invoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.InvoiceId))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Status))
	}
	if m.NextStatus != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.NextStatus))
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.Meta != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n5, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)))
		n6, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.UpdatedAt != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)))
		n7, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.TxId))
	}
	if m.InvoiceId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.InvoiceId))
	}
	if m.Key != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)))
		n8, err := github_com_gogo_protobuf_types.StdStringMarshalTo(*m.Key, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Strategy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Strategy)))
		i += copy(dAtA[i:], m.Strategy)
	}
	if m.Provider != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Provider))
	}
	if m.ProviderOperId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdString(*m.ProviderOperId)))
		n9, err := github_com_gogo_protobuf_types.StdStringMarshalTo(*m.ProviderOperId, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ProviderOperStatus != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdString(*m.ProviderOperStatus)))
		n10, err := github_com_gogo_protobuf_types.StdStringMarshalTo(*m.ProviderOperStatus, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Meta != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n11, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Status))
	}
	if m.NextStatus != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.NextStatus))
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)))
		n12, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.CreatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.UpdatedAt != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)))
		n13, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Oper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Oper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OperId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.OperId))
	}
	if m.InvoiceId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.InvoiceId))
	}
	if m.TxId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.TxId))
	}
	if m.SrcAccId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.SrcAccId))
	}
	if m.Hold {
		dAtA[i] = 0x28
		i++
		if m.Hold {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HoldAccId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.HoldAccId))
	}
	if m.DstAccId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.DstAccId))
	}
	if m.Strategy != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Strategy))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Amount))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Meta != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)))
		n14, err := github_com_gogo_protobuf_types.StdBytesMarshalTo(*m.Meta, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Status != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x6a
	i++
	i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)))
	n15, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.UpdatedAt != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintModels(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)))
		n16, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Currency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrId != 0 {
		n += 1 + sovModels(uint64(m.CurrId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccId != 0 {
		n += 1 + sovModels(uint64(m.AccId))
	}
	if m.CurrId != 0 {
		n += 1 + sovModels(uint64(m.CurrId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Balance != 0 {
		n += 1 + sovModels(uint64(m.Balance))
	}
	if m.BalanceAccepted != 0 {
		n += 1 + sovModels(uint64(m.BalanceAccepted))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovModels(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovModels(uint64(l))
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Invoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InvoiceId != 0 {
		n += 1 + sovModels(uint64(m.InvoiceId))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModels(uint64(m.Status))
	}
	if m.NextStatus != 0 {
		n += 1 + sovModels(uint64(m.NextStatus))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxId != 0 {
		n += 1 + sovModels(uint64(m.TxId))
	}
	if m.InvoiceId != 0 {
		n += 1 + sovModels(uint64(m.InvoiceId))
	}
	if m.Key != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdString(*m.Key)
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Provider != 0 {
		n += 1 + sovModels(uint64(m.Provider))
	}
	if m.ProviderOperId != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdString(*m.ProviderOperId)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ProviderOperStatus != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdString(*m.ProviderOperStatus)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModels(uint64(m.Status))
	}
	if m.NextStatus != 0 {
		n += 1 + sovModels(uint64(m.NextStatus))
	}
	if m.CreatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.CreatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Oper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperId != 0 {
		n += 1 + sovModels(uint64(m.OperId))
	}
	if m.InvoiceId != 0 {
		n += 1 + sovModels(uint64(m.InvoiceId))
	}
	if m.TxId != 0 {
		n += 1 + sovModels(uint64(m.TxId))
	}
	if m.SrcAccId != 0 {
		n += 1 + sovModels(uint64(m.SrcAccId))
	}
	if m.Hold {
		n += 2
	}
	if m.HoldAccId != 0 {
		n += 1 + sovModels(uint64(m.HoldAccId))
	}
	if m.DstAccId != 0 {
		n += 1 + sovModels(uint64(m.DstAccId))
	}
	if m.Strategy != 0 {
		n += 1 + sovModels(uint64(m.Strategy))
	}
	if m.Amount != 0 {
		n += 1 + sovModels(uint64(m.Amount))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Meta != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdBytes(*m.Meta)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModels(uint64(m.Status))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovModels(uint64(l))
	if m.UpdatedAt != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovModels(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Currency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Currency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Currency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrId", wireType)
			}
			m.CurrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccId", wireType)
			}
			m.AccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrId", wireType)
			}
			m.CurrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceAccepted", wireType)
			}
			m.BalanceAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BalanceAccepted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= InvoiceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStatus", wireType)
			}
			m.NextStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStatus |= InvoiceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = new(string)
			}
			if err := github_com_gogo_protobuf_types.StdStringUnmarshal(m.Key, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= Provider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderOperId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderOperId == nil {
				m.ProviderOperId = new(string)
			}
			if err := github_com_gogo_protobuf_types.StdStringUnmarshal(m.ProviderOperId, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderOperStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderOperStatus == nil {
				m.ProviderOperStatus = new(string)
			}
			if err := github_com_gogo_protobuf_types.StdStringUnmarshal(m.ProviderOperStatus, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStatus", wireType)
			}
			m.NextStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextStatus |= TxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Oper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Oper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Oper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperId", wireType)
			}
			m.OperId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			m.InvoiceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvoiceId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			m.TxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcAccId", wireType)
			}
			m.SrcAccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcAccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hold = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldAccId", wireType)
			}
			m.HoldAccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldAccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstAccId", wireType)
			}
			m.DstAccId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstAccId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= OperStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = new([]byte)
			}
			if err := github_com_gogo_protobuf_types.StdBytesUnmarshal(m.Meta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OperStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthModels
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModels
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModels(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthModels
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModels = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels   = fmt.Errorf("proto: integer overflow")
)
